#
#	Modelisation thermique 
#	BRUN, ROUX
#

DEBUT(PAR_LOT='NON',);

ArrG	= ('Sub_All','Ailes','Bride','Cordon_1','Cordon_2','Cordon_3','Cordon_4','Cordon_5','Cordon_6','Cordon_7','Cordon_8','Cordon_9','Cordon_10','Cordon_11','Cordon_12',)
Xo		= (		65.92,	34.08,	97.75,	2.25,	34.08,	65.92,	97.75,	2.25,	2.25,	97.75,	97.75,	2.25,)
Yo		= (		97.75,	2.25,	34.08,	65.92,	97.75,	2.25,	65.92,	34.08,	97.75,	2.25,	97.75,	2.25,)
Zo		= (		-0.75,	-0.75,	-0.75,	-0.75,	-0.75,	-0.75,	-0.75,	-0.75,	-0.75,	-0.75,	-0.75,	-0.75,)
tf		= (0.,	20.,	40.,	60.,	80.,	100.,	120.,	140.,	160.,	180.,	200.,	220.,	240.,)

# Parametres de soudage
v         = 200./60.	   	# Vitesse de soudage en mm/s
eta       = 0.8				# Coef de soudage TIG
U         = 10.    			# en V
I         = 65.    			# en A
tm        = 2.     			# temps de mainitien en s
ts        = 31.83/v+tm		# temps de soudage en s

# Variable pour forme de flux de chaleur (goldak)
ang       = 45./180*pi    	# Angle pour la rotation en rad
a         = 1.4     		# en mm
b         = 1.5     		# en mm
cf        = 2.     			# en mm
cr        = 3.     			# en mm
ff        = 1.4				# en mm
fr        = 0.6				# en mm
Qw        = eta*U*I			# en W
Coeff     = 6*sqrt(3)*ff*Qw/(a*b*cf*pi*sqrt(pi))
Coefr     = 6*sqrt(3)*fr*Qw/(a*b*cr*pi*sqrt(pi))

MAT		= {}
LIST	= {}
gold	= {}
FLUT	= {}

for i in range(1, 13):
	
	# Definition des goldak
	if   i in (1,5,9):
		def goldakHeatSource(X, Y, Z, t):
			yy = cos(ang)*(Y-Yo[i-1])-sin(ang)*(Z-Zo[i-1])
			zz = sin(ang)*(Y-Yo[i-1])+cos(ang)*(Z-Zo[i-1])
			# Avant le temps de maintien
			if t < tm+tf[i-1]:
				Qfi = Coeff*exp(-3.*(((X-Xo[i-1])/cf)**2+(yy/a)**2+(zz/b)**2))
				Qri = Coefr*exp(-3.*(((X-Xo[i-1])/cr)**2+(yy/a)**2+(zz/b)**2))
				# Rear
				if X < Xo[i-1]:
					Q = Qri
				# Front
				else:
					Q = Qfi
			# Après le temps de maintien	
			else:
				Qf = Coeff*exp(-3.*(((X-v*((t-tf[i-1])-tm)-Xo[i-1])/cf)**2+(yy/a)**2+(zz/b)**2))
				Qr = Coefr*exp(-3.*(((X-v*((t-tf[i-1])-tm)-Xo[i-1])/cr)**2+(yy/a)**2+(zz/b)**2))
				# Rear
				if X < v*((t-tf[i-1])-tm)+Xo[i-1]:
					Q = Qr
				# Front
				else:
					Q = Qf
			if t > ts+tf[i-1]:
				Q = 0.
			return Q
	
	elif i in (2,6,10):
		def goldakHeatSource(X, Y, Z, t):
			yy = cos(ang)*(Y-Yo[i-1])+sin(ang)*(Z-Zo[i-1])
			zz = -sin(ang)*(Y-Yo[i-1])+cos(ang)*(Z-Zo[i-1])
			# Avant le temps de maintien	
			if t < tm+tf[i-1]:
				Qfi = Coeff*exp(-3.*(((X-Xo[i-1])/cf)**2+(yy/a)**2+(zz/b)**2))
				Qri = Coefr*exp(-3.*(((X-Xo[i-1])/cr)**2+(yy/a)**2+(zz/b)**2))
				# Rear
				if X > Xo[i-1]:
					Q = Qri
				# Front
				else:
					Q = Qfi
			# Après le temps de maintien
			else:
				Qf = Coeff*exp(-3.*(((X+v*((t-tf[i-1])-tm)-Xo[i-1])/cf)**2+(yy/a)**2+(zz/b)**2))
				Qr = Coefr*exp(-3.*(((X+v*((t-tf[i-1])-tm)-Xo[i-1])/cr)**2+(yy/a)**2+(zz/b)**2))
				# Rear
				if X > v*((t-tf[i-1])-tm)+Xo[i-1]:
					Q = Qr
				# Front
				else:
					Q = Qf
			if t > ts+tf[i-1]:
				Q = 0.
			return Q
	
	elif i in (3,7,11):
		def goldakHeatSource(X, Y, Z, t):
			xx = cos(ang)*(X-Xo[i-1])-sin(ang)*(Z-Zo[i-1])
			zz = sin(ang)*(X-Xo[i-1])+cos(ang)*(Z-Zo[i-1])
			# Avant le temps de maintien
			if t < tm+tf[i-1]:
				Qfi = Coeff*exp(-3.*(((Y-Yo[i-1])/cf)**2+(xx/a)**2+(zz/b)**2))
				Qri = Coefr*exp(-3.*(((Y-Yo[i-1])/cr)**2+(xx/a)**2+(zz/b)**2))
				# Rear
				if Y > Yo[i-1]:
					Q = Qri
				# Front
				else:
					Q = Qfi
			# Après le temps de maintien
			else:
				Qf = Coeff*exp(-3.*(((Y+v*((t-tf[i-1])-tm)-Yo[i-1])/cf)**2+(xx/a)**2+(zz/b)**2))
				Qr = Coefr*exp(-3.*(((Y+v*((t-tf[i-1])-tm)-Yo[i-1])/cr)**2+(xx/a)**2+(zz/b)**2))
				# Rear
				if Y > v*((t-tf[i-1])-tm)+Yo[i-1]:
					Q = Qr
				# Front
				else:
					Q = Qf
			if t > ts+tf[i-1]:
		            Q = 0.
			return Q

	elif i in (4,8,12):
		def goldakHeatSource(X, Y, Z, t):
			xx = cos(ang)*(X-Xo[i-1])+sin(ang)*(Z-Zo[i-1])
			zz = -sin(ang)*(X-Xo[i-1])+cos(ang)*(Z-Zo[i-1])
			# Avant le temps de maintien
			if t < tm+tf[i-1]:
				Qfi = Coeff*exp(-3.*(((Y-Yo[i-1])/cf)**2+(xx/a)**2+(zz/b)**2))
				Qri = Coefr*exp(-3.*(((Y-Yo[i-1])/cr)**2+(xx/a)**2+(zz/b)**2))
				# Rear
				if Y < Yo[i-1]:
					Q = Qri
				# Front
				else:
					Q = Qfi
			# Après le temps de maintien
			else:
				Qf = Coeff*exp(-3.*(((Y-v*((t-tf[i-1])-tm)-Yo[i-1])/cf)**2+(xx/a)**2+(zz/b)**2))
				Qr = Coefr*exp(-3.*(((Y-v*((t-tf[i-1])-tm)-Yo[i-1])/cr)**2+(xx/a)**2+(zz/b)**2))
				# Rear
				if Y < v*((t-tf[i-1])-tm)+Yo[i-1]:
					Q = Qr
				# Front
				else:
					Q = Qf
			if t > ts+tf[i-1]:
		            Q = 0.
			return Q

	
	if i == 1:
		# Lire le maillage
		MA = LIRE_MAILLAGE(UNITE  = 20,);

		# Definition des materiaux - Les unites ont ete bascule pour que l unite de longueur soit le mm
		INCO625=DEFI_MATERIAU(THER=_F(LAMBDA=0.0165,RHO_CP=0.0039,),);
		AIR=DEFI_MATERIAU(THER=_F(LAMBDA=2.62e-5,RHO_CP=1.2048e-5,),);

		# Affectation du modele de thermique
		MODELE=AFFE_MODELE(MAILLAGE=MA,AFFE=_F(TOUT='OUI',PHENOMENE='THERMIQUE',MODELISATION='3D',),);
	
	# Definition des instants de calcul pour une analyse non lineraire
	LIST[i]=DEFI_LIST_REEL(DEBUT=tf[i-1],INTERVALLE=(_F(JUSQU_A=tf[i],NOMBRE=40,),),);

	# Affectation du materiau au group
	if i == 12:
		MAT[i]=AFFE_MATERIAU(MAILLAGE=MA,
		                  AFFE=(_F(TOUT='OUI',MATER=INCO625,),),);
	else:
		MAT[i]=AFFE_MATERIAU(MAILLAGE=MA,
		                  AFFE=(_F(GROUP_MA = (ArrG[:i+3]),MATER=INCO625,),
		                        _F(GROUP_MA = (ArrG[i+3:]),MATER=AIR,),),);

	# Voir ouvrage simulation du soudage pour plus de precision Goldak ou Bergheau
	gold[i] = FORMULE(VALE='goldakHeatSource(X,Y,Z,INST)',goldakHeatSource=goldakHeatSource,NOM_PARA=('X','Y','Z','INST',),);

	# La source de chaleur est appliquee sur la partie du maillage en interaction avec l'arc.
	FLUT[i]=AFFE_CHAR_THER_F(MODELE=MODELE,SOURCE=_F(GROUP_MA=(ArrG[i+2]),SOUR = gold[i],),);
	
	if i == 1:
		# Introduction de l echange entre l air et la plaque q = coef_h ( T_piece - Temp_ext )
		ECH=AFFE_CHAR_THER(MODELE=MODELE,ECHANGE=_F(GROUP_MA=('Convection'),COEF_H   = 20.0e-6,TEMP_EXT = 20.0,),);
	
	# Calcul thermique transitoire les resultats sont dans l objet TEMP
	if i == 1:
		TEMP=THER_LINEAIRE(MODELE=MODELE,
		                   CHAM_MATER=MAT[i],
		                   EXCIT=(_F(CHARGE=FLUT[i],),),
		                   INCREMENT=_F(LIST_INST=LIST[i],),
		                   ETAT_INIT=_F(VALE=20.E0,),
		                   SOLVEUR=_F(METHODE='MULT_FRONT',
		                              RENUM='METIS',
		                              NPREC=8,
		                              STOP_SINGULIER='OUI',),);
	
	else :
		TEMP=THER_LINEAIRE(reuse= TEMP,
						   MODELE=MODELE,
		                   CHAM_MATER=MAT[i],
		                   EXCIT=(_F(CHARGE=FLUT[i],),),
		                   INCREMENT=_F(LIST_INST=LIST[i],),
		                   ETAT_INIT=_F(EVOL_THER = TEMP,),
		                   SOLVEUR=_F(METHODE='MULT_FRONT',
		                              RENUM='METIS',
		                              NPREC=8,
		                              STOP_SINGULIER='OUI',),);
	
# Impression des resultats
IMPR_RESU(FORMAT='MED',RESU=_F(RESULTAT=TEMP,GROUP_MA=(ArrG[:]),NOM_CHAM='TEMP',),);

FIN();
